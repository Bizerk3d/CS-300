# CS-300
Coursework for CS-300 at SNHU

What was the problem you were solving in the projects for this course?

What is the best way to solve a problem, really.  In this instance, it was specifically what is the best data structure for designing a product that loads course information and then allows for methods of manipulation/retrieval of that data.  In general, the approach to the problem means sometimes looking at the most efficient method, sometimes that means looking at the fastest.  Sometimes that means choosing the right data structure, and sometimes that means choosing the right algorithm for the job.  Often, the problem involves utilizing all those considerations to find the "answer."

How did you approach the problem? Consider why data structures are important to understand.
I tried to balance a variety of factors, such as which would be most useful if this project were to continue to expland and develop down the road.  There's no sense designing a solution that isn't scalable.  I also tried to consider how efficient the memory usage was, and how fast the data could be added and/or retrieved.  Finally, there's at least some consideration that has to be paid to ease of implementation.  If a project takes 100% more time but only gains a ~10% increase in quality, often the client might not find that to be valuable.

How did you overcome any roadblocks you encountered while going through the activities or project?
I heavily utilized online resources, specifically Stack Overflow, YouTube guides, Geeks for Geeks, and various other references for C++.  By working on these projects far in advance I was almost always able to solve any points that got me stuck.  I also always take time to remember to walk away and reflect and allow my brain to not get so tunnel-visioned on a project.

How has your work on this project expanded your approach to designing software and developing programs?
It taught me a lot about data structures and algorithms, so I have a better grasp of what the initial planning or designing phase for a solution might involve.  It also taught me a lot about debugging and the methods that I find helpful for that.  It also heavily reinforced the value of good pseudocode!

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
I like to think that I gained a bit of knowledge about what makes good comments in code, but otherwise that was the area I felt most comfortable in.  In terms of adaptability, it definitely taught me a lot about thinking about what other possibilities might occur with the product - is this ready for a new feature, or for a massive influx of data if that were to come about?  Just keeping those considerations in my mind is definitely something I wasn't focused on previously.  Finally, a similar thought for maintability - reinforced the concept of modularity, because I don't want to rewrite every part of my code when something changes - that makes maintenance painful, so keeping strong object oriented principles in mind as I design became more important to me.
